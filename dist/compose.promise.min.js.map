{"version":3,"sources":["../src/compose.promise.js"],"names":[],"mappings":"uNAMM,GAAiB,SAAC,CAAD,CAAU,CAAV,QAAmB,GAAQ,IAAR,CAAa,CAAb,CAAnB,C,CACjB,EAAiB,kBAAW,GAAQ,IAAR,CAAa,kBAAoB,UAAd,QAAO,EAAb,CAAb,CAAX,C,CASjB,EAAwB,kBAAW,WAAY,4BAAR,CAAQ,sBAAR,CAAQ,iBACnD,GAAmB,CAAf,KAAI,MAAR,CAAsB,MAAO,kBAAM,GAAQ,OAAR,EAAN,CAAP,CACtB,GAAI,EAAe,CAAf,CAAJ,CAAyB,KAAM,IAAI,UAAJ,CAAc,qBAAd,CAAN,CAEzB,EAAI,OAAJ,EAJmD,IAM7C,GAAO,EAAI,CAAJ,CANsC,CAO7C,EAAO,EAAI,KAAJ,CAAU,CAAV,CAPsC,CASnD,MAAO,uCAAI,CAAJ,sBAAI,CAAJ,uBAAa,GAAK,MAAL,CAAY,CAAZ,CAA4B,EAAQ,OAAR,GAAkB,IAAlB,CAAuB,iBAAM,gBAAQ,CAAR,CAAN,CAAvB,CAA5B,CAAb,CACR,CAV6B,C,CAY9B,EAAO,OAAP,CAAiB,EAAsB,OAAtB,C,CACjB,EAAO,OAAP,CAAe,KAAf,CAAuB,C","file":"compose.promise.min.js","sourcesContent":["/**\n * Exports a library that composes promise returning functions.\n * @since 5/8/18\n * @file\n */\n\nconst promiseReducer = (current, next) => current.then(next);\nconst hasNonFunction = fnArray => fnArray.some(fn => typeof fn !== 'function');\n\n/**\n * Like fp.compose for Promise returning functions.\n * The right most function can have unlimited arity, all others will be treated as unary.\n * @param {...function} fns The functions to compose. These can be either sync or Promise\n * returning functions. However, the returned function will always return a Promise.\n * @returns {function} A function composed using the ones provided.\n */\nconst ComposePromiseFactory = Promise => (...fns) => {\n  if (fns.length === 0) return () => Promise.resolve();\n  if (hasNonFunction(fns)) throw new TypeError('Expected a function');\n\n  fns.reverse();\n\n  const head = fns[0];\n  const rest = fns.slice(1);\n\n  return (...args) => rest.reduce(promiseReducer, Promise.resolve().then(() => head(...args)));\n};\n\nmodule.exports = ComposePromiseFactory(Promise);\nmodule.exports.using = ComposePromiseFactory;\n"]}