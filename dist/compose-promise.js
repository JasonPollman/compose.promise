'use strict'; /**
               * @param {Array} fnArray An array to determine "all function-ness".
               * @returns {boolean} True if a non-function was found in the array.
               */
var hasNonFunction = function hasNonFunction(fnArray) {return fnArray.some(function (fn) {return typeof fn !== 'function';});};

/**
                                                                                                                                 * Used by `composePromise` and `Array.prototype.reduce` to create a "composed function chain".
                                                                                                                                 * @param {function} current The current function to invoke in the compose chain.
                                                                                                                                 * @param {function} next The next function to invoke in the compose chain.
                                                                                                                                 * @returns {function} A function that calls `current` with the given input
                                                                                                                                 * and then invokes next with `current`'s resolution value.
                                                                                                                                 */
var getReductionIterateeForComposePromise = function getReductionIterateeForComposePromise(Promise) {return (
    function (current, next) {return function () {for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}return Promise.resolve().then(function () {return current.apply(undefined, args);}).then(next);};});};


/**
                                                                                                                                                                                                                                                                              * Like fp.compose for Promise returning functions.
                                                                                                                                                                                                                                                                              * This will create a function that will invoke all of the given function arguments in a
                                                                                                                                                                                                                                                                              * chain from right to left. The *last* function is provided all initial input arguments and
                                                                                                                                                                                                                                                                              * the resolve value from each is passed into the next until all functions have been called.
                                                                                                                                                                                                                                                                              * That is the right most function can have unlimited arity, all others will be treated as unary.
                                                                                                                                                                                                                                                                              * @param {...function} fns The functions to compose. These can be either sync or Promise
                                                                                                                                                                                                                                                                              * returning functions. However, this method will *always* return a promise.
                                                                                                                                                                                                                                                                              * @returns {function} A function composed of the provided ones.
                                                                                                                                                                                                                                                                              */
var ComposePromiseFactory = function ComposePromiseFactory(Promise) {return function () {for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {fns[_key2] = arguments[_key2];}
    if (fns.length === 0) return function () {return Promise.resolve();};
    if (hasNonFunction(fns)) throw new TypeError('Expected a function');

    // Note, Array.prototype.reverse mutates the original array, so fns[0]...
    var initial = function initial() {for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}return Promise.resolve().then(function () {return fns[0].apply(fns, args);});};
    return fns.reverse().slice(1).reduce(getReductionIterateeForComposePromise(Promise), initial);
  };};

// Create a default export that uses native Promises and attach a function
// so that the user can provide any promise library they'd like (bluebird, for example).
module.exports = ComposePromiseFactory(Promise);
module.exports.using = ComposePromiseFactory;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21wb3NlLXByb21pc2UuanMiXSwibmFtZXMiOlsiaGFzTm9uRnVuY3Rpb24iLCJmbkFycmF5Iiwic29tZSIsImZuIiwiZ2V0UmVkdWN0aW9uSXRlcmF0ZWVGb3JDb21wb3NlUHJvbWlzZSIsImN1cnJlbnQiLCJuZXh0IiwiYXJncyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIkNvbXBvc2VQcm9taXNlRmFjdG9yeSIsImZucyIsImxlbmd0aCIsIlR5cGVFcnJvciIsImluaXRpYWwiLCJyZXZlcnNlIiwic2xpY2UiLCJyZWR1Y2UiLCJtb2R1bGUiLCJleHBvcnRzIiwidXNpbmciXSwibWFwcGluZ3MiOiJjQUFBOzs7O0FBSUEsSUFBTUEsaUJBQWlCLFNBQWpCQSxjQUFpQixrQkFBV0MsUUFBUUMsSUFBUixDQUFhLHNCQUFNLE9BQU9DLEVBQVAsS0FBYyxVQUFwQixFQUFiLENBQVgsRUFBdkI7O0FBRUE7Ozs7Ozs7QUFPQSxJQUFNQyx3Q0FBd0MsU0FBeENBLHFDQUF3QztBQUM1QyxjQUFDQyxPQUFELEVBQVVDLElBQVYsVUFBbUIsK0NBQUlDLElBQUosZ0RBQUlBLElBQUosaUNBQWFDLFFBQVFDLE9BQVIsR0FBa0JDLElBQWxCLENBQXVCLG9CQUFNTCx5QkFBV0UsSUFBWCxDQUFOLEVBQXZCLEVBQStDRyxJQUEvQyxDQUFvREosSUFBcEQsQ0FBYixFQUFuQixFQUQ0QyxHQUE5Qzs7O0FBSUE7Ozs7Ozs7Ozs7QUFVQSxJQUFNSyx3QkFBd0IsU0FBeEJBLHFCQUF3QixrQkFBVyxZQUFZLG9DQUFSQyxHQUFRLHFEQUFSQSxHQUFRO0FBQ25ELFFBQUlBLElBQUlDLE1BQUosS0FBZSxDQUFuQixFQUFzQixPQUFPLG9CQUFNTCxRQUFRQyxPQUFSLEVBQU4sRUFBUDtBQUN0QixRQUFJVCxlQUFlWSxHQUFmLENBQUosRUFBeUIsTUFBTSxJQUFJRSxTQUFKLENBQWMscUJBQWQsQ0FBTjs7QUFFekI7QUFDQSxRQUFNQyxVQUFVLFNBQVZBLE9BQVUsdUNBQUlSLElBQUoscURBQUlBLElBQUosbUNBQWFDLFFBQVFDLE9BQVIsR0FBa0JDLElBQWxCLENBQXVCLG9CQUFNRSxJQUFJLENBQUosYUFBVUwsSUFBVixDQUFOLEVBQXZCLENBQWIsRUFBaEI7QUFDQSxXQUFPSyxJQUFJSSxPQUFKLEdBQWNDLEtBQWQsQ0FBb0IsQ0FBcEIsRUFBdUJDLE1BQXZCLENBQThCZCxzQ0FBc0NJLE9BQXRDLENBQTlCLEVBQThFTyxPQUE5RSxDQUFQO0FBQ0QsR0FQNkIsRUFBOUI7O0FBU0E7QUFDQTtBQUNBSSxPQUFPQyxPQUFQLEdBQWlCVCxzQkFBc0JILE9BQXRCLENBQWpCO0FBQ0FXLE9BQU9DLE9BQVAsQ0FBZUMsS0FBZixHQUF1QlYscUJBQXZCIiwiZmlsZSI6ImNvbXBvc2UtcHJvbWlzZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhcmFtIHtBcnJheX0gZm5BcnJheSBBbiBhcnJheSB0byBkZXRlcm1pbmUgXCJhbGwgZnVuY3Rpb24tbmVzc1wiLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYSBub24tZnVuY3Rpb24gd2FzIGZvdW5kIGluIHRoZSBhcnJheS5cbiAqL1xuY29uc3QgaGFzTm9uRnVuY3Rpb24gPSBmbkFycmF5ID0+IGZuQXJyYXkuc29tZShmbiA9PiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpO1xuXG4vKipcbiAqIFVzZWQgYnkgYGNvbXBvc2VQcm9taXNlYCBhbmQgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIHRvIGNyZWF0ZSBhIFwiY29tcG9zZWQgZnVuY3Rpb24gY2hhaW5cIi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN1cnJlbnQgVGhlIGN1cnJlbnQgZnVuY3Rpb24gdG8gaW52b2tlIGluIHRoZSBjb21wb3NlIGNoYWluLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbmV4dCBUaGUgbmV4dCBmdW5jdGlvbiB0byBpbnZva2UgaW4gdGhlIGNvbXBvc2UgY2hhaW4uXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBjYWxscyBgY3VycmVudGAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRcbiAqIGFuZCB0aGVuIGludm9rZXMgbmV4dCB3aXRoIGBjdXJyZW50YCdzIHJlc29sdXRpb24gdmFsdWUuXG4gKi9cbmNvbnN0IGdldFJlZHVjdGlvbkl0ZXJhdGVlRm9yQ29tcG9zZVByb21pc2UgPSBQcm9taXNlID0+IChcbiAgKGN1cnJlbnQsIG5leHQpID0+ICguLi5hcmdzKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGN1cnJlbnQoLi4uYXJncykpLnRoZW4obmV4dClcbik7XG5cbi8qKlxuICogTGlrZSBmcC5jb21wb3NlIGZvciBQcm9taXNlIHJldHVybmluZyBmdW5jdGlvbnMuXG4gKiBUaGlzIHdpbGwgY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGludm9rZSBhbGwgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uIGFyZ3VtZW50cyBpbiBhXG4gKiBjaGFpbiBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSAqbGFzdCogZnVuY3Rpb24gaXMgcHJvdmlkZWQgYWxsIGluaXRpYWwgaW5wdXQgYXJndW1lbnRzIGFuZFxuICogdGhlIHJlc29sdmUgdmFsdWUgZnJvbSBlYWNoIGlzIHBhc3NlZCBpbnRvIHRoZSBuZXh0IHVudGlsIGFsbCBmdW5jdGlvbnMgaGF2ZSBiZWVuIGNhbGxlZC5cbiAqIFRoYXQgaXMgdGhlIHJpZ2h0IG1vc3QgZnVuY3Rpb24gY2FuIGhhdmUgdW5saW1pdGVkIGFyaXR5LCBhbGwgb3RoZXJzIHdpbGwgYmUgdHJlYXRlZCBhcyB1bmFyeS5cbiAqIEBwYXJhbSB7Li4uZnVuY3Rpb259IGZucyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuIFRoZXNlIGNhbiBiZSBlaXRoZXIgc3luYyBvciBQcm9taXNlXG4gKiByZXR1cm5pbmcgZnVuY3Rpb25zLiBIb3dldmVyLCB0aGlzIG1ldGhvZCB3aWxsICphbHdheXMqIHJldHVybiBhIHByb21pc2UuXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IEEgZnVuY3Rpb24gY29tcG9zZWQgb2YgdGhlIHByb3ZpZGVkIG9uZXMuXG4gKi9cbmNvbnN0IENvbXBvc2VQcm9taXNlRmFjdG9yeSA9IFByb21pc2UgPT4gKC4uLmZucykgPT4ge1xuICBpZiAoZm5zLmxlbmd0aCA9PT0gMCkgcmV0dXJuICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICBpZiAoaGFzTm9uRnVuY3Rpb24oZm5zKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBmdW5jdGlvbicpO1xuXG4gIC8vIE5vdGUsIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlIG11dGF0ZXMgdGhlIG9yaWdpbmFsIGFycmF5LCBzbyBmbnNbMF0uLi5cbiAgY29uc3QgaW5pdGlhbCA9ICguLi5hcmdzKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGZuc1swXSguLi5hcmdzKSk7XG4gIHJldHVybiBmbnMucmV2ZXJzZSgpLnNsaWNlKDEpLnJlZHVjZShnZXRSZWR1Y3Rpb25JdGVyYXRlZUZvckNvbXBvc2VQcm9taXNlKFByb21pc2UpLCBpbml0aWFsKTtcbn07XG5cbi8vIENyZWF0ZSBhIGRlZmF1bHQgZXhwb3J0IHRoYXQgdXNlcyBuYXRpdmUgUHJvbWlzZXMgYW5kIGF0dGFjaCBhIGZ1bmN0aW9uXG4vLyBzbyB0aGF0IHRoZSB1c2VyIGNhbiBwcm92aWRlIGFueSBwcm9taXNlIGxpYnJhcnkgdGhleSdkIGxpa2UgKGJsdWViaXJkLCBmb3IgZXhhbXBsZSkuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2VQcm9taXNlRmFjdG9yeShQcm9taXNlKTtcbm1vZHVsZS5leHBvcnRzLnVzaW5nID0gQ29tcG9zZVByb21pc2VGYWN0b3J5O1xuIl19
