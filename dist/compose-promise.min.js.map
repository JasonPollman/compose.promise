{"version":3,"sources":["../src/compose-promise.js"],"names":[],"mappings":"uNAIM,GAAiB,kBAAW,GAAQ,IAAR,CAAa,kBAAoB,UAAd,QAAO,EAAb,CAAb,CAAX,C,CASjB,EAAwC,kBAC5C,UAAC,CAAD,CAAU,CAAV,QAAmB,uCAAI,CAAJ,sBAAI,CAAJ,uBAAa,GAAQ,OAAR,GAAkB,IAAlB,CAAuB,iBAAM,gBAAW,CAAX,CAAN,CAAvB,EAA+C,IAA/C,CAAoD,CAApD,CAAb,CAAnB,CAD4C,C,CAcxC,EAAwB,kBAAW,WAAY,4BAAR,CAAQ,sBAAR,CAAQ,iBACnD,GAAmB,CAAf,KAAI,MAAR,CAAsB,MAAO,kBAAM,GAAQ,OAAR,EAAN,CAAP,CACtB,GAAI,EAAe,CAAf,CAAJ,CAAyB,KAAM,IAAI,UAAJ,CAAc,qBAAd,CAAN,CAIzB,MAAO,GAAI,OAAJ,GAAc,KAAd,CAAoB,CAApB,EAAuB,MAAvB,CAA8B,EAAsC,CAAtC,CAA9B,CADS,QAAV,QAAU,8BAAI,CAAJ,sBAAI,CAAJ,uBAAa,GAAQ,OAAR,GAAkB,IAAlB,CAAuB,iBAAM,GAAI,CAAJ,UAAU,CAAV,CAAN,CAAvB,CAAb,CACT,CACR,CAP6B,C,CAW9B,EAAO,OAAP,CAAiB,EAAsB,OAAtB,C,CACjB,EAAO,OAAP,CAAe,KAAf,CAAuB,C","file":"compose-promise.min.js","sourcesContent":["/**\n * @param {Array} fnArray An array to determine \"all function-ness\".\n * @returns {boolean} True if a non-function was found in the array.\n */\nconst hasNonFunction = fnArray => fnArray.some(fn => typeof fn !== 'function');\n\n/**\n * Used by `composePromise` and `Array.prototype.reduce` to create a \"composed function chain\".\n * @param {function} current The current function to invoke in the compose chain.\n * @param {function} next The next function to invoke in the compose chain.\n * @returns {function} A function that calls `current` with the given input\n * and then invokes next with `current`'s resolution value.\n */\nconst getReductionIterateeForComposePromise = Promise => (\n  (current, next) => (...args) => Promise.resolve().then(() => current(...args)).then(next)\n);\n\n/**\n * Like fp.compose for Promise returning functions.\n * This will create a function that will invoke all of the given function arguments in a\n * chain from right to left. The *last* function is provided all initial input arguments and\n * the resolve value from each is passed into the next until all functions have been called.\n * That is the right most function can have unlimited arity, all others will be treated as unary.\n * @param {...function} fns The functions to compose. These can be either sync or Promise\n * returning functions. However, this method will *always* return a promise.\n * @returns {function} A function composed of the provided ones.\n */\nconst ComposePromiseFactory = Promise => (...fns) => {\n  if (fns.length === 0) return () => Promise.resolve();\n  if (hasNonFunction(fns)) throw new TypeError('Expected a function');\n\n  // Note, Array.prototype.reverse mutates the original array, so fns[0]...\n  const initial = (...args) => Promise.resolve().then(() => fns[0](...args));\n  return fns.reverse().slice(1).reduce(getReductionIterateeForComposePromise(Promise), initial);\n};\n\n// Create a default export that uses native Promises and attach a function\n// so that the user can provide any promise library they'd like (bluebird, for example).\nmodule.exports = ComposePromiseFactory(Promise);\nmodule.exports.using = ComposePromiseFactory;\n"]}